# 7.2 CTAP1/U2F認証器でCTAP2のauthencatorMakeCredentialコマンドを使う
プラットフォームは以下の処理を行います([図: マッピング: CTAP1/U2Fから・へのWebAuthn authenticatorMakeCredentialの登録メッセージ](https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.pdf#page=44&zoom=100,0,38)):

1. プラットフォームはCTAP2プロトコル概要に定義されている `authenticatorGetInfo` コマンドを用いて認証機情報の取得を試みます
    * CTAP1/U2F認証器はコマンドエラーもしくは正しくない形式のCBORレスポンスを返します。何らかの失敗があるとき、プラットフォームはCTAP1/U2Fプロトコルにフォールバックできます。

2. CTAP2のauthenticatorMakeCredentialリクエストをU2FREGISTERリクエストへマッピングします。
    * プラットフォームはCTAP1/U2F認証器が補完できないパラメータがCTAP2リクエスト内に含まれていないかを検証します
        * プラットフォームが次のステップを処理するため、以下の全ての条件はtrueになっている必要があります。もし以下すべての条件がtrueでなかった場合、プラットフォームは `CTAP2_ERR_UNSUPPORTED_OPTION` エラーを吐きます。
            * pubKeyCredParamsはES256アルゴリズム(-7)を使用しなくてはいけない
            * オプションに "rk" がtrueでセットされていてはいけない
            * オプションに "uv" がtrueでセットされていてはいけない
        * もしexcludeListが空でない場合
            * もしexcludeListが空でない場合、プラットフォームはexludeList内の各クレデンシャルID(キーハンドル)を用いてCTAP1/U2F認証器に対してcheck-onlyを表す制御バイトをつけた署名要求を出します。もしいずれの結果もエラーにならなかった場合、それはすでに知っているデバイスだという意味になります。その後、プラットフォームはダミーの登録リクエスト(ダミーのアプリID及び不正なチャレンジをつけて)をCTAP1/U2F認証器に対して送り、間違いなく除外されているか確認しなければいけません。これはRPの出力でトークンが既に登録されていることを知る前にユーザーがCTAP1/U2F認証器に触れる必要があるということになります。
    * CTAP2リクエスト内のclientDataHashパラメータをCTAP1/U2Fチャレンジのパラメータとして用います(32バイト)
    * rpIdHashには32バイトで初期化されたバイト配列にrp.idパラメータのSHA-256ハッシュがCTAP1/U2Fアプリケーションパラメータとして入ります(32バイト)

3. U2F_REGISTERリクエストをU2FRawMsgs仕様で示すとおり認証器に送信します
4. U2F登録のレスポンスメッセージ(参考: FIDO U2F Raw Message Formats v1.0 registration-response-message-success)をCTAP2 authenticatorMakeCredentialのレスポンスにマッピングします
    * authenticatorDataを認証器から受け取ったU2F登録のレスポンスメッセージから生成します
        * attestedCredDataを初期化します:
            * credentialIdLengthはCTAP1/U2Fレスポンスのキーハンドルの長さで初期化されたクレデンシャルIDの長さを示すビッグエンディアンの2バイト符号なし整数を入れます
            * credentialIdにはCTAP1/U2Fレスポンスのキーハンドルバイトで初期化されたcredentialIdLengthバイト配列が入ります
            * x9encodeUserPublicKeyはU2F登録のレスポンスメッセージ(U2FRawMsgs)で返ってきたユーザーの公開鍵が入ります。coseEncodedCredentialPublicKeyはANS X9.62/Sec-1 v2 非圧縮曲線点表現(SEC1V2)からCOSE_Key表現(RFC8152 7章)へと変換を行った結果が入ります。
            * attestedCredDataは以下の構造のバイト配列が入ります:
            | 長さ(バイト)       | 説明                   | 値                                    |
            | ------------------ | ---------------------- | ------------------------------------- |
            | 16                 | 認証器のAAGUID         | 全バイトが0                           |
            | 2                  | クレデンシャルIDの長さ | credentialIdLengthで初期化            |
            | credentialIdLength | クレデンシャルID       | credentialIdで初期化                  |
            | 77                 | 公開鍵                 | coseEncodedCredntialPublicKeyで初期化 |
            * authenticatorDataの初期化:
                * flagsの頭のビット(ビット0, UP)及び6番目のビット(ビット6, AT)がセットされ、それ以外の全てのビットは0とします(ビット0が最下位ビットです)。Autneticator Dataに関するWebAuthn仕様についても参照してください。
                * signCountは符号なし4バイト整数で0で初期化されます
                * authenticatorDataは以下の構造のバイト配列になります:
                | 長さ(バイト) | 説明                         | 値                            |
                | ------------ | ---------------------------- | ----------------------------- |
                | 32           | rp.idのSHA-256ハッシュ       | rpIdHashで初期化              |
                | 1            | フラグ                       | flagsで初期化                 |
                | 4            | 署名カウンタ(signCount)      | signCountで初期化             |
                | 可変長       | 証明済みクレデンシャルデータ | attestedCredDataで初期化      |
            * attestationStatementに以下のキー及び値を持つCBORマップ(参考: Attestation Objectの生成[WebAuthn]内の"attStmtTemplate")が入ります。
                * "x5c"はCTAP1/U2Fレスポンスから抽出したアテステーションの証明書
                * "sig"はU2F登録のレスポンスメッセージ内の"signature"のバイト
            * attestationObjectは以下のキー及び値を持つCBORマップになります:
                * "authData"にauthenticatorData
                * "fmt"に"fido-u2f"
                * "attStmt"にattestationStatement
6. attestationObjectを呼び出し元に返却します


