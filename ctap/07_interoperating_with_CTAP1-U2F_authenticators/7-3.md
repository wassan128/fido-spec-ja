# 7.3 CTAP1/U2F認証器でCTAP2 authenticatorGetAssertionコマンドを使う
プラットフォームは以下の処理を行います([図: マッピング: CTAP1/U2Fから・へのWebAuthn authenticatorGetAssertionの認証メッセージ](https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.pdf#page=48&zoom=100,0,38)):

1. プラットフォームはCTAP2プロトコル概要で仕様定義されているauthenticatorGetInfoコマンドを使って認証器情報の取得を試みます
    * CTAP1/U2F認証器はコマンドエラーもしくは正しくない形式のCBORレスポンスを返します。何らかの失敗があるとき、プラットフォームはCTAP1/U2Fプロトコルにフォールバックできます。

2. authenticatorgetAssertionリクエストをU2F_AUTHENTICATEリクエストにマッピングします
    * プラットフォームはCTAP1/U2F認証器が補完できないパラメータがCTAP2リクエスト内に含まれていないかを検証します
        * プラットフォームが次のステップを処理するため、以下の全ての条件はtrueになっている必要があります。もし以下すべての条件がtrueでなかった場合、プラットフォームは `CTAP2_ERR_UNSUPPORTED_OPTION` エラーを吐きます。
            * オプションに "uv" がtrueでセットされていてはいけない
            * allowListは一つ以上のクレデンシャルを含んでいなければならない
        * もしallowListが2つ以上のクレデンシャルを含んでいる場合、リスト内をループで網羅し、それぞれ異なるU2F_AUTHENTICATEコマンドを認証器に送ります。クレデンシャルリスト内の各クレデンシャルは、以下に示すようにCTAP2 authenticatorGetAssertionリクエストからU2F_AUTHENTICATEにマッピングされます:
            * controlByteは以下に示すようなバイトで初期化されます:
                * "up"がfalseにセットされている場合、0x08とする(user-presece及び署名は強制しない)
                * USBならば0x07(check-only)とする。これはユーザー入力を待つことによるブロッキングを防ぐべきである。もしレスポンスが成功状態で返ってきたなら、user-presence及び署名を強制するよう再呼び出しする
                * NFCならば0x03(user-presence及び署名を強制)とする。タップ操作によりユーザーの存在は確認できているのでブロックしない
            * CTAP2のclientDataHashパラメータをCTAP1/U2Fチャレンジパラメータとして使います(32バイト)
            * rpIdHashには32バイトで初期化されたバイト配列にrp.idパラメータのSHA-256ハッシュがCTAP1/U2Fアプリケーションパラメータとして入ります(32バイト)
            * credentialIdはPublicKeyCredentialDescriptorのidを示すバイト配列で初期化されます
            * keyHandleLengthはcredentialIdを格納するバイト配列の長さ(バイト)で初期化されます
            * u2fAuthenticateRequestは以下の構造をもつバイト配列になります:
            | 長さ(バイト)    | 説明                       | 値                               |
            | --------------- | -------------------------- | -------------------------------- |
            | 32              | チャレンジパラメータ       | clientDataHashパラメータで初期化 |
            | 32              | アプリケーションパラメータ | rpIdHashのバイトで初期化         |
            | 1               | キーハンドルの長さ         | keyHandleLengthの値で初期化      |
            | keyHandleLength | キーハンドル               | credentialIdのバイトで初期化     |
            そしてControl ByteをフレーミングP1のバイトにします
3. u2fAuthenticateRequestを認証機に対して送ります
4. U2F認証のレスポンス(参考: "Authentication Response Message: Success section of U2FRawMsgs")をCTAP2 authenticatorGetAssertionレスポンスメッセージにマッピングします:
    * 認証器から受け取ったU2F認証のレスポンスメッセージからauthenticatorDataを生成します
        * 0ビット目(UPを示すビット)と1ビット目をCTAP1/U2Fレスポンスからコピーし、それぞれCTAP2のフラグへとセットします。その他のすべてのビットは0でセットします。参考: 0ビット目が最下位ビットです。WebAuthnのAuthenticator Dataの章も参照してください。
        * signCountは4バイトの符号なし整数でCTAP1/U2Fレスポンスのカウンターの値で初期化されます
        * authenticatorDataは以下の構造を持つバイト配列で初期化されます:
        | 長さ(バイト) | 説明                    | 値                          |
        | ------------ | ----------------------- | --------------------------- |
        | 32           | rp.idのSHA256ハッシュ   | rpIdHashのバイトで初期化    |
        | 1            | フラグ                  | flagsの値で初期化           |
        | 4            | 署名カウンタ(signCount) | signCountのバイトで初期化   |

    * authenticatorgetAssertionResponseは以下のキー及び値を持つCBORマップが入ります:
        * 0x01にallowList内でレスポンスが成功となっているクレデンシャルをセット
        * 0x02にauthenticatorDataのバイトをセット
        * 0x03にCTAP1/U2F認証レスポンスメッセージの署名フィールドをセット




